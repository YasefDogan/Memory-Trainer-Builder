using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Runtime.CompilerServices;
using System.Collections.Concurrent;
using System.Threading;
using System.IO;

namespace cheat_engine
{
    public partial class Form1 : Form
    {
        private List<FoundAddress> lastFoundAddresses = new List<FoundAddress>();
        private string lastSearchType = "Int";

        // --- New fields for batched UI updates ---
        private readonly ConcurrentQueue<string> _logQueue = new ConcurrentQueue<string>();
        private readonly ConcurrentQueue<string> _resultQueue = new ConcurrentQueue<string>();
        private volatile string _latestStatus = null;
        private volatile bool _clearResultsRequested = false;
        private readonly System.Windows.Forms.Timer _uiFlushTimer;
        // ------------------------------------------

        public Form1()
        {
            InitializeComponent();

            // Programmatic export button: small, placed near bottom-left. If you use the Designer, remove this and add via Designer.
            try
            {
                var btnExport = new Button();
                btnExport.Name = "btnExport";
                btnExport.Text = "Dışa Aktar";
                btnExport.Size = new System.Drawing.Size(100, 26);
                // Adjust location if it overlaps other controls in your form
                btnExport.Location = new System.Drawing.Point(12, 410);
                btnExport.Click += (s, e) => ExportFoundAddressesToFile();
                this.Controls.Add(btnExport);
            }
            catch { }

            // Setup UI flush timer to batch updates and avoid flooding the STA thread
            _uiFlushTimer = new System.Windows.Forms.Timer();
            _uiFlushTimer.Interval = 150; // ms - tune as needed
            _uiFlushTimer.Tick += (s, e) => FlushUiQueues();
            _uiFlushTimer.Start();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            RefreshProcessList();
            // LoadUploadedFiles is optional; ensure method exists
            LoadUploadedFiles();
        }

        // Load lastFoundAddresses into the flow panel; create per-address row: address label, textbox for new value, Apply button
        private void btnLoadAddresses_Click(object sender, EventArgs e)
        {
            try
            {
                if (flpAddressesUpload == null || flpAddressesUpload.IsDisposed) return;
                flpAddressesUpload.Controls.Clear();

                var snapshot = lastFoundAddresses.ToList();
                foreach (var fa in snapshot)
                {
                    var panel = new Panel();
                    panel.Width = flpAddressesUpload.ClientSize.Width - 25;
                    panel.Height = 30;

                    var lbl = new Label();
                    lbl.Text = $"0x{fa.Address.ToString("X")} ({MapSubtypeToShort(fa.Subtype)})";
                    lbl.AutoSize = false;
                    lbl.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
                    lbl.Location = new System.Drawing.Point(3, 6);
                    lbl.Size = new System.Drawing.Size(250, 18);
                    panel.Controls.Add(lbl);

                    var txt = new TextBox();
                    txt.Name = "txtAddrVal_" + fa.Address.ToString("X");
                    txt.Location = new System.Drawing.Point(260, 3);
                    txt.Size = new System.Drawing.Size(200, 22);
                    txt.Text = string.Empty;
                    panel.Controls.Add(txt);

                    var btn = new Button();
                    btn.Text = "Uygula";
                    btn.Tag = new Tuple<FoundAddress, TextBox>(fa, txt);
                    btn.Location = new System.Drawing.Point(470, 2);
                    btn.Size = new System.Drawing.Size(75, 24);
                    btn.Click += (s2, e2) =>
                    {
                        try
                        {
                            var tup = (Tuple<FoundAddress, TextBox>)((Button)s2).Tag;
                            ApplyAddressValue(tup.Item1, tup.Item2.Text);
                        }
                        catch (Exception ex) { AppendLog("Apply button error: " + ex.Message); }
                    };
                    panel.Controls.Add(btn);

                    flpAddressesUpload.Controls.Add(panel);
                }
            }
            catch (Exception ex)
            {
                AppendLog("LoadAddresses error: " + ex.Message);
            }
        }

        // Browse button handler for upload tab
        private void btnBrowseUpload_Click(object sender, EventArgs e)
        {
            try
            {
                if (openFileDialog1 == null) openFileDialog1 = new OpenFileDialog();
                openFileDialog1.Multiselect = false;
                openFileDialog1.Filter = "Tüm dosyalar (*.*)|*.*";
                if (openFileDialog1.ShowDialog() == DialogResult.OK)
                {
                    string selected = openFileDialog1.FileName;
                    if (txtUploadPath != null && !txtUploadPath.IsDisposed && txtUploadPath.IsHandleCreated)
                    {
                        try { txtUploadPath.Invoke((Action)(() => txtUploadPath.Text = selected)); } catch { txtUploadPath.Text = selected; }
                    }
                }
            }
            catch (Exception ex)
            {
                AddStatus("Dosya seçme hatası: " + ex.Message);
                AppendLog("Browse error: " + ex.Message);
            }
        }

        // Upload button handler: copy selected file into uploads folder
        private void btnUpload_Click(object sender, EventArgs e)
        {
            try
            {
                string source = (txtUploadPath != null) ? txtUploadPath.Text : null;
                if (string.IsNullOrWhiteSpace(source) || !File.Exists(source))
                {
                    MessageBox.Show("Lütfen yüklemek için bir dosya seçin.");
                    return;
                }

                string uploadsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "uploads");
                Directory.CreateDirectory(uploadsDir);

                string destFileName = Path.GetFileName(source);
                string destPath = Path.Combine(uploadsDir, destFileName);

                File.Copy(source, destPath, true);

                AddStatus("Dosya yüklendi: " + destFileName);
                AppendLog($"Uploaded file {source} -> {destPath}");

                MessageBox.Show("Dosya başarıyla yüklendi:\n" + destPath);

                // After upload, try to load addresses from this file and create per-address UI rows
                try { LoadAddressesFromFile(destPath); } catch (Exception ex) { AppendLog("LoadAddressesFromFile error: " + ex.Message); }
            }
            catch (Exception ex)
            {
                AddStatus("Yükleme hatası: " + ex.Message);
                AppendLog("Upload error: " + ex.Message);
                MessageBox.Show("Yükleme sırasında hata: " + ex.Message);
            }
        }

        // Load uploaded files or prepare uploads folder (no UI list in new layout)
        private void LoadUploadedFiles()
        {
            try
            {
                string uploadsDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "uploads");
                if (!Directory.Exists(uploadsDir)) Directory.CreateDirectory(uploadsDir);
                // No automatic listing in new UI; user can upload files with btnUpload
            }
            catch { }
        }

        // Load addresses from a file (format: lines like "0x1234 int") and create UI rows
        private void LoadAddressesFromFile(string path)
        {
            if (!File.Exists(path)) throw new FileNotFoundException(path);
            var lines = File.ReadAllLines(path);
            var parsed = new List<(IntPtr addr, string subtype)>();
            foreach (var ln in lines)
            {
                var s = ln.Trim();
                if (string.IsNullOrEmpty(s)) continue;
                var parts = s.Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length < 1) continue;
                string addrPart = parts[0];
                string typePart = (parts.Length >= 2) ? parts[1] : "Int32";
                try
                {
                    if (addrPart.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) addrPart = addrPart.Substring(2);
                    long val = long.Parse(addrPart, System.Globalization.NumberStyles.HexNumber);
                    IntPtr addr = new IntPtr(val);
                    string subtype = MapShortToSubtype(typePart);
                    parsed.Add((addr, subtype));
                }
                catch (Exception ex) { AppendLog("Parse line failed: " + ln + " -> " + ex.Message); }
            }

            if (flpAddressesUpload == null || flpAddressesUpload.IsDisposed) return;
            flpAddressesUpload.Controls.Clear();

            foreach (var p in parsed)
            {
                var fa = new FoundAddress { Address = p.addr, Subtype = p.subtype, Value = null };
                CreateAddressRow(fa);
            }
        }

        // Create a single UI row in the flow panel for an address with read/write buttons
        private void CreateAddressRow(FoundAddress fa)
        {
            try
            {
                var panel = new Panel();
                panel.Width = flpAddressesUpload.ClientSize.Width - 25;
                panel.Height = 36;

                var lbl = new Label();
                lbl.Text = $"0x{fa.Address.ToString("X")}";
                lbl.AutoSize = false;
                lbl.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
                lbl.Location = new System.Drawing.Point(3, 6);
                lbl.Size = new System.Drawing.Size(120, 24);
                panel.Controls.Add(lbl);

                var txt = new TextBox();
                txt.Name = "txtAddrVal_" + fa.Address.ToString("X");
                txt.Location = new System.Drawing.Point(130, 6);
                txt.Size = new System.Drawing.Size(240, 22);
                panel.Controls.Add(txt);

                var btnRead = new Button();
                btnRead.Text = "Oku";
                btnRead.Location = new System.Drawing.Point(380, 5);
                btnRead.Size = new System.Drawing.Size(60, 24);
                btnRead.Tag = new Tuple<FoundAddress, TextBox>(fa, txt);
                btnRead.Click += (s, e) =>
                {
                    try
                    {
                        var tup = (Tuple<FoundAddress, TextBox>)((Button)s).Tag;
                        var val = ReadAddressValue(tup.Item1);
                        if (val != null) tup.Item2.Text = val;
                    }
                    catch (Exception ex) { AppendLog("Read button error: " + ex.Message); }
                };
                panel.Controls.Add(btnRead);

                var btnWriteSingle = new Button();
                btnWriteSingle.Text = "Yaz";
                btnWriteSingle.Location = new System.Drawing.Point(450, 5);
                btnWriteSingle.Size = new System.Drawing.Size(60, 24);
                btnWriteSingle.Tag = new Tuple<FoundAddress, TextBox>(fa, txt);
                btnWriteSingle.Click += (s, e) =>
                {
                    try
                    {
                        var tup = (Tuple<FoundAddress, TextBox>)((Button)s).Tag;
                        ApplyAddressValue(tup.Item1, tup.Item2.Text);
                    }
                    catch (Exception ex) { AppendLog("Write button error: " + ex.Message); }
                };
                panel.Controls.Add(btnWriteSingle);

                flpAddressesUpload.Controls.Add(panel);
            }
            catch (Exception ex) { AppendLog("CreateAddressRow error: " + ex.Message); }
        }

        // Read a single address from target process and return string representation according to subtype
        private string ReadAddressValue(FoundAddress fa)
        {
            try
            {
                if (cbProcesses.SelectedItem == null) { MessageBox.Show("Lütfen bir process seçin."); return null; }
                var item = cbProcesses.SelectedItem as ProcessItem;
                var process = item.Process;

                IntPtr hProcess = OpenProcess(PROCESS_WM_READ | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION, false, process.Id);
                if (hProcess == IntPtr.Zero) { MessageBox.Show("Process açılamadı (okuma izni yok)."); return null; }
                try
                {
                    int len = 8;
                    switch (fa.Subtype)
                    {
                        case "Int8": case "UInt8": len = 1; break;
                        case "Int16": case "UInt16": len = 2; break;
                        case "Int32": case "UInt32": case "Float32": len = 4; break;
                        case "Int64": case "UInt64": case "Float64": len = 8; break;
                        default: len = 4; break;
                    }
                    byte[] buffer = new byte[len];
                    IntPtr bytesRead;
                    bool ok = ReadProcessMemory(hProcess, fa.Address, buffer, buffer.Length, out bytesRead);
                    if (!ok) { int errc = Marshal.GetLastWin32Error(); AppendLog($"ReadProcessMemory failed at 0x{fa.Address.ToString("X")} Err={errc}"); return null; }
                    int actual = bytesRead.ToInt32();
                    if (actual <= 0) return null;
                    switch (fa.Subtype)
                    {
                        case "Int8": return ((sbyte)buffer[0]).ToString();
                        case "UInt8": return buffer[0].ToString();
                        case "Int16": return BitConverter.ToInt16(buffer, 0).ToString();
                        case "UInt16": return BitConverter.ToUInt16(buffer, 0).ToString();
                        case "Int32": return BitConverter.ToInt32(buffer, 0).ToString();
                        case "UInt32": return BitConverter.ToUInt32(buffer, 0).ToString();
                        case "Int64": return BitConverter.ToInt64(buffer, 0).ToString();
                        case "UInt64": return BitConverter.ToUInt64(buffer, 0).ToString();
                        case "Float32": return BitConverter.ToSingle(buffer, 0).ToString(CultureInfo.InvariantCulture);
                        case "Float64": return BitConverter.ToDouble(buffer, 0).ToString(CultureInfo.InvariantCulture);
                        default: return BitConverter.ToString(buffer, 0, Math.Min(actual, buffer.Length));
                    }
                }
                finally { CloseHandle(hProcess); }
            }
            catch (Exception ex) { AppendLog("ReadAddressValue exception: " + ex.Message); return null; }
        }

        // Map short type token from file back to our internal subtype
        private string MapShortToSubtype(string shortType)
        {
            if (string.IsNullOrEmpty(shortType)) return "Int32";
            shortType = shortType.Trim().ToLowerInvariant();
            switch (shortType)
            {
                case "int8": return "Int8";
                case "uint8": return "UInt8";
                case "int16": return "Int16";
                case "uint16": return "UInt16";
                case "int32": case "int": return "Int32";
                case "uint32": return "UInt32";
                case "int64": return "Int64";
                case "uint64": return "UInt64";
                case "float": case "float32": return "Float32";
                case "double": case "float64": return "Float64";
                case "bytes": case "hex": case "bytes(hex)": return "Bytes (Hex)";
                default: return shortType;
            }
        }

        // Thread-safe UI helpers
        
        class ProcessItem
        {
            public Process Process { get; set; }
            public string Display { get; set; }
            public override string ToString() { return Display; }
        }

        class FoundAddress
        {
            public IntPtr Address { get; set; }
            public string Subtype { get; set; }
            public byte[] Value { get; set; }
        }

        // Thread-safe logging/result/status helpers
        private void AppendLog(string text)
        {
            try
            {
                string line = $"[{DateTime.Now:HH:mm:ss}] {text}" + Environment.NewLine;
                if (_logQueue == null) return;
                _logQueue.Enqueue(line);
            }
            catch { }
        }

        private void FlushUiQueues()
        {
            try
            {
                // Flush logs
                if (!_logQueue.IsEmpty && txtLog != null && !txtLog.IsDisposed && txtLog.IsHandleCreated)
                {
                    var sb = new StringBuilder();
                    while (_logQueue.TryDequeue(out var ln)) sb.Append(ln);
                    if (sb.Length > 0)
                    {
                        try { txtLog.Invoke((Action)(() => txtLog.AppendText(sb.ToString()))); } catch { }
                    }
                }

                // Handle clear request for results
                if (_clearResultsRequested && lstResults != null && !lstResults.IsDisposed && lstResults.IsHandleCreated)
                {
                    try { lstResults.Invoke((Action)(() => lstResults.Items.Clear())); } catch { }
                    _clearResultsRequested = false;
                }

                // Flush results
                if (!_resultQueue.IsEmpty && lstResults != null && !lstResults.IsDisposed && lstResults.IsHandleCreated)
                {
                    var items = new List<string>();
                    while (_resultQueue.TryDequeue(out var r)) items.Add(r);
                    if (items.Count > 0)
                    {
                        try { lstResults.Invoke((Action)(() => { foreach (var it in items) lstResults.Items.Add(it); })); } catch { }
                    }
                }

                // Latest status
                if (_latestStatus != null && lblStatus != null && !lblStatus.IsDisposed && lblStatus.IsHandleCreated)
                {
                    var s = Interlocked.Exchange(ref _latestStatus, null);
                    if (s != null)
                    {
                        try { lblStatus.Invoke((Action)(() => lblStatus.Text = s)); } catch { }
                    }
                }
            }
            catch { }
        }

        private void EnqueueResult(string text) => _resultQueue.Enqueue(text);

        private void AddResult(string text)
        {
            try
            {
                if (lstResults == null || lstResults.IsDisposed || !lstResults.IsHandleCreated)
                {
                    _resultQueue.Enqueue(text);
                    return;
                }
                _resultQueue.Enqueue(text);
            }
            catch { }
        }

        private void AddStatus(string text)
        {
            try { Interlocked.Exchange(ref _latestStatus, text); } catch { }
        }

        private void ClearResults() { try { _clearResultsRequested = true; } catch { } }

        // Export found addresses to file (used by export button)
        private void ExportFoundAddressesToFile()
        {
            try
            {
                var snapshot = lastFoundAddresses.ToList();
                if (!snapshot.Any()) { MessageBox.Show("Kaydedilecek adres yok."); return; }
                var lines = new List<string>();
                foreach (var fa in snapshot)
                {
                    string addr = $"0x{fa.Address.ToString("X")}";
                    string shortType = MapSubtypeToShort(fa.Subtype);
                    lines.Add($"{addr} {shortType}");
                }
                string path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "found_addresses.txt");
                File.WriteAllLines(path, lines, Encoding.UTF8);
                AddStatus($"Adresler dosyaya yazıldı: {path}");
                AppendLog($"Exported {lines.Count} addresses to {path}");
                MessageBox.Show("Adresler dışa aktarıldı:\n" + path);
            }
            catch (Exception ex) { AddStatus("Dışa aktarma hatası: " + ex.Message); AppendLog("Export error: " + ex.Message); }
        }

        private string MapSubtypeToShort(string subtype)
        {
            switch (subtype)
            {
                case "Int8": return "int8";
                case "UInt8": return "uint8";
                case "Int16": return "int16";
                case "UInt16": return "uint16";
                case "Int32": return "int32";
                case "UInt32": return "uint32";
                case "Int64": return "int64";
                case "UInt64": return "uint64";
                case "Float32": return "float";
                case "Float64": return "double";
                case "Bytes (Hex)": return "bytes";
                default: return subtype;
            }
        }

        // Designer export button handler
        private void btnExport_Click(object sender, EventArgs e)
        {
            ExportFoundAddressesToFile();
        }

        // P/Invoke declarations (needed for Read/Write/Query memory)
        [DllImport("kernel32.dll")]
        static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out IntPtr lpNumberOfBytesRead);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern UIntPtr VirtualQueryEx(IntPtr hProcess, IntPtr lpAddress, out MEMORY_BASIC_INFORMATION lpBuffer, UIntPtr dwLength);

        [DllImport("kernel32.dll")]
        static extern bool CloseHandle(IntPtr hObject);

        [StructLayout(LayoutKind.Sequential)]
        private struct MEMORY_BASIC_INFORMATION
        {
            public IntPtr BaseAddress;
            public IntPtr AllocationBase;
            public uint AllocationProtect;
            public IntPtr RegionSize;
            public uint State;
            public uint Protect;
            public uint Type;
        }

        const int PROCESS_WM_READ = 0x0010;
        const int PROCESS_QUERY_INFORMATION = 0x0400;
        const int PROCESS_VM_OPERATION = 0x0008;
        const int PROCESS_VM_WRITE = 0x0020;
        const uint MEM_COMMIT = 0x1000;
        const uint PAGE_NOACCESS = 0x01;
        const uint PAGE_GUARD = 0x100;
        const uint PAGE_READWRITE = 0x04;
        const uint PAGE_WRITECOPY = 0x08;
        const uint PAGE_EXECUTE_READWRITE = 0x40;
        const uint PAGE_EXECUTE_WRITECOPY = 0x80;

        // Apply a single address write from UI (converts string to bytes based on subtype and writes)
        private void ApplyAddressValue(FoundAddress fa, string newValueText)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(newValueText)) { MessageBox.Show("Lütfen bir değer girin."); return; }

                if (!GetBytesForType(fa.Subtype, newValueText, out byte[] bytes, out string err)) { MessageBox.Show("Değer parse hatası: " + err); return; }

                if (cbProcesses.SelectedItem == null) { MessageBox.Show("Lütfen bir process seçin."); return; }
                var item = cbProcesses.SelectedItem as ProcessItem;
                var process = item.Process;

                IntPtr hProcess = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION, false, process.Id);
                if (hProcess == IntPtr.Zero) { MessageBox.Show("Process açılamadı (yazma izni yok)."); return; }

                try
                {
                    IntPtr written;
                    bool ok = WriteProcessMemory(hProcess, fa.Address, bytes, bytes.Length, out written);
                    if (ok) { AppendLog($"Wrote {written.ToInt32()} bytes to 0x{fa.Address.ToString("X")}." ); AddResult($"0x{fa.Address.ToString("X")} - Uygulandı"); }
                    else { int errc = Marshal.GetLastWin32Error(); AppendLog($"WriteProcessMemory failed at 0x{fa.Address.ToString("X")} Err={errc}"); MessageBox.Show("Yazma başarısız: Err=" + errc); }
                }
                finally { CloseHandle(hProcess); }
            }
            catch (Exception ex)
            {
                AppendLog("ApplyAddressValue exception: " + ex.Message);
                MessageBox.Show("Hata: " + ex.Message);
            }
        }

    }
}
