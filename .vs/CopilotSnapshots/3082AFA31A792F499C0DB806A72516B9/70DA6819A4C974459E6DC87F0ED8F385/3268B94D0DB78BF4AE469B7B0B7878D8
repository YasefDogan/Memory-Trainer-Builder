using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Runtime.CompilerServices;
using System.Collections.Concurrent;
using System.Threading;
using System.IO;

namespace cheat_engine
{
    public partial class Form1 : Form
    {
        private List<FoundAddress> lastFoundAddresses = new List<FoundAddress>();
        private string lastSearchType = "Int";

        // --- New fields for batched UI updates ---
        private readonly ConcurrentQueue<string> _logQueue = new ConcurrentQueue<string>();
        private readonly ConcurrentQueue<string> _resultQueue = new ConcurrentQueue<string>();
        private volatile string _latestStatus = null;
        private volatile bool _clearResultsRequested = false;
        private readonly System.Windows.Forms.Timer _uiFlushTimer;
        // ------------------------------------------

        public Form1()
        {
            InitializeComponent();
            this.Text = "YasefDogan-cheat engine C# recration";

            // Load and set the application icon
            try
            {
                // Önce ICO dosyasını dene
                string iconPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "cheat-logo.ico");
                if (File.Exists(iconPath))
                {
                    this.Icon = new System.Drawing.Icon(iconPath);
                }
                else
                {
                    // ICO yoksa PNG'den yüksek çözünürlüklü ikon oluştur
                    string pngPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "cheat logo.png");
                    if (File.Exists(pngPath))
                    {
                        using (var originalBmp = new System.Drawing.Bitmap(pngPath))
                        {
                            // Dikdörtgen görüntüden ortadaki kare kısmı kırp
                            int size = Math.Min(originalBmp.Width, originalBmp.Height);
                            int x = (originalBmp.Width - size) / 2;
                            int y = (originalBmp.Height - size) / 2;
                            
                            var cropRect = new System.Drawing.Rectangle(x, y, size, size);
                            var croppedBmp = originalBmp.Clone(cropRect, originalBmp.PixelFormat);
                            
                            // 256x256 boyutunda yüksek kaliteli ikon oluştur
                            var iconBmp = new System.Drawing.Bitmap(croppedBmp, new System.Drawing.Size(256, 256));
                            IntPtr hIcon = iconBmp.GetHicon();
                            this.Icon = System.Drawing.Icon.FromHandle(hIcon);
                            
                            // Memory leak'i önlemek için
                            croppedBmp.Dispose();
                            iconBmp.Dispose();
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                // Icon yükleme hatası - log'a yazdır
                Debug.WriteLine($"Icon yükleme hatası: {ex.Message}");
            }

            // Setup UI flush timer to batch updates and avoid flooding the STA thread
            _uiFlushTimer = new System.Windows.Forms.Timer();
            _uiFlushTimer.Interval = 150; // ms - tune as needed
            _uiFlushTimer.Tick += (s, e) => FlushUiQueues();
            _uiFlushTimer.Start();
            
            // Apply dark theme
            ApplyDarkTheme();
        }

        private void ApplyDarkTheme()
        {
            // Ana form renkleri
            this.BackColor = System.Drawing.Color.FromArgb(30, 30, 30);
            this.ForeColor = System.Drawing.Color.FromArgb(220, 220, 220);

            // TabControl
            tabControlMain.BackColor = System.Drawing.Color.FromArgb(45, 45, 48);
            
            // Tarama sekmesi
            tabScan.BackColor = System.Drawing.Color.FromArgb(37, 37, 38);
            ApplyDarkThemeToControls(tabScan);
            
            // İçe Aktar sekmesi
            tabUpload.BackColor = System.Drawing.Color.FromArgb(37, 37, 38);
            ApplyDarkThemeToControls(tabUpload);
            
            // Özel renkler
            lstResults.BackColor = System.Drawing.Color.FromArgb(30, 30, 30);
            lstResults.ForeColor = System.Drawing.Color.FromArgb(220, 220, 220);
            
            txtLog.BackColor = System.Drawing.Color.FromArgb(30, 30, 30);
            txtLog.ForeColor = System.Drawing.Color.FromArgb(180, 180, 180);
            
            txtLogUpload.BackColor = System.Drawing.Color.FromArgb(30, 30, 30);
            txtLogUpload.ForeColor = System.Drawing.Color.FromArgb(180, 180, 180);
            
            progressBarScan.BackColor = System.Drawing.Color.FromArgb(45, 45, 48);
            progressBarScan.ForeColor = System.Drawing.Color.FromArgb(0, 122, 204);
            
            flpAddressesUpload.BackColor = System.Drawing.Color.FromArgb(37, 37, 38);
        }

        private void ApplyDarkThemeToControls(System.Windows.Forms.Control parent)
        {
            foreach (System.Windows.Forms.Control ctrl in parent.Controls)
            {
                if (ctrl is System.Windows.Forms.Button)
                {
                    var btn = (System.Windows.Forms.Button)ctrl;
                    btn.BackColor = System.Drawing.Color.FromArgb(62, 62, 64);
                    btn.ForeColor = System.Drawing.Color.FromArgb(241, 241, 241);
                    btn.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
                    btn.FlatAppearance.BorderColor = System.Drawing.Color.FromArgb(80, 80, 80);
                }
                else if (ctrl is System.Windows.Forms.TextBox)
                {
                    ctrl.BackColor = System.Drawing.Color.FromArgb(51, 51, 55);
                    ctrl.ForeColor = System.Drawing.Color.FromArgb(241, 241, 241);
                }
                else if (ctrl is System.Windows.Forms.ComboBox)
                {
                    var cb = (System.Windows.Forms.ComboBox)ctrl;
                    cb.BackColor = System.Drawing.Color.FromArgb(51, 51, 55);
                    cb.ForeColor = System.Drawing.Color.FromArgb(241, 241, 241);
                    cb.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
                }
                else if (ctrl is System.Windows.Forms.Label)
                {
                    ctrl.BackColor = System.Drawing.Color.Transparent;
                    ctrl.ForeColor = System.Drawing.Color.FromArgb(220, 220, 220);
                }
                else if (ctrl is System.Windows.Forms.ListBox)
                {
                    ctrl.BackColor = System.Drawing.Color.FromArgb(30, 30, 30);
                    ctrl.ForeColor = System.Drawing.Color.FromArgb(220, 220, 220);
                }
                else if (ctrl is System.Windows.Forms.FlowLayoutPanel)
                {
                    ctrl.BackColor = System.Drawing.Color.FromArgb(37, 37, 38);
                    ApplyDarkThemeToControls(ctrl);
                }
                else if (ctrl is System.Windows.Forms.Panel)
                {
                    ctrl.BackColor = System.Drawing.Color.FromArgb(45, 45, 48);
                    ApplyDarkThemeToControls(ctrl);
                }
            }
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            RefreshProcessList();
            RefreshProcessListUpload();
            LoadUploadedFiles();
        }

        private void RefreshProcessList()
        {
            try
            {
                cbProcesses.Items.Clear();
                var procs = Process.GetProcesses().OrderBy(p => p.ProcessName).ToList();
                foreach (var p in procs)
                {
                    try { cbProcesses.Items.Add(new ProcessItem { Process = p, Display = $"{p.ProcessName} ({p.Id})" }); }
                    catch { }
                }
                if (cbProcesses.Items.Count > 0) cbProcesses.SelectedIndex = 0;
            }
            catch (Exception ex)
            {
                AddStatus("Refresh hata: " + ex.Message);
            }
        }

        private void RefreshProcessListUpload()
        {
            try
            {
                cbProcessesUpload.Items.Clear();
                var procs = Process.GetProcesses().OrderBy(p => p.ProcessName).ToList();
                foreach (var p in procs)
                {
                    try { cbProcessesUpload.Items.Add(new ProcessItem { Process = p, Display = $"{p.ProcessName} ({p.Id})" }); }
                    catch { }
                }
                if (cbProcessesUpload.Items.Count > 0) cbProcessesUpload.SelectedIndex = 0;
            }
            catch (Exception ex)
            {
                AddStatus("Refresh hata: " + ex.Message);
            }
        }

        private void btnRefresh_Click(object sender, EventArgs e)
        {
            RefreshProcessList();
        }

        private void btnRefreshUpload_Click(object sender, EventArgs e)
        {
            RefreshProcessListUpload();
        }

        // P/Invoke declarations
        [DllImport("kernel32.dll")]
        static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out IntPtr lpNumberOfBytesRead);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern UIntPtr VirtualQueryEx(IntPtr hProcess, IntPtr lpAddress, out MEMORY_BASIC_INFORMATION lpBuffer, UIntPtr dwLength);

        [DllImport("kernel32.dll")]
        static extern bool CloseHandle(IntPtr hObject);

        [StructLayout(LayoutKind.Sequential)]
        private struct MEMORY_BASIC_INFORMATION
        {
            public IntPtr BaseAddress;
            public IntPtr AllocationBase;
            public uint AllocationProtect;
            public IntPtr RegionSize;
            public uint State;
            public uint Protect;
            public uint Type;
        }

        const int PROCESS_WM_READ = 0x0010;
        const int PROCESS_QUERY_INFORMATION = 0x0400;
        const int PROCESS_VM_OPERATION = 0x0008;
        const int PROCESS_VM_WRITE = 0x0020;
        const uint MEM_COMMIT = 0x1000;
        const uint PAGE_NOACCESS = 0x01;
        const uint PAGE_GUARD = 0x100;
        const uint PAGE_READWRITE = 0x04;
        const uint PAGE_WRITECOPY = 0x08;
        const uint PAGE_EXECUTE_READWRITE = 0x40;
        const uint PAGE_EXECUTE_WRITECOPY = 0x80;

        // Build bytes for given subtype
        private bool GetBytesForType(string type, string text, out byte[] data, out string error)
        {
            data = null; error = null;
            try
            {
                switch (type)
                {
                    case "Int8":
                        if (sbyte.TryParse(text, out sbyte sbyteVal)) data = new byte[] { unchecked((byte)sbyteVal) }; else { error = "Geçersiz Int8"; return false; }
                        break;
                    case "UInt8":
                        if (byte.TryParse(text, out byte byteVal)) data = new byte[] { byteVal }; else { error = "Geçersiz UInt8"; return false; }
                        break;
                    case "Int16":
                        if (short.TryParse(text, out short shortVal)) data = BitConverter.GetBytes(shortVal); else { error = "Geçersiz Int16"; return false; }
                        break;
                    case "UInt16":
                        if (ushort.TryParse(text, out ushort ushortVal)) data = BitConverter.GetBytes(ushortVal); else { error = "Geçersiz UInt16"; return false; }
                        break;
                    case "Int32":
                        if (int.TryParse(text, out int int32Val)) data = BitConverter.GetBytes(int32Val); else { error = "Geçersiz Int32"; return false; }
                        break;
                    case "UInt32":
                        if (uint.TryParse(text, out uint uint32Val)) data = BitConverter.GetBytes(uint32Val); else { error = "Geçersiz UInt32"; return false; }
                        break;
                    case "Int64":
                        if (long.TryParse(text, out long int64Val)) data = BitConverter.GetBytes(int64Val); else { error = "Geçersiz Int64"; return false; }
                        break;
                    case "UInt64":
                        if (ulong.TryParse(text, out ulong uint64Val)) data = BitConverter.GetBytes(uint64Val); else { error = "Geçersiz UInt64"; return false; }
                        break;
                    case "Float32":
                        if (float.TryParse(text, NumberStyles.Float, CultureInfo.InvariantCulture, out float floatVal)) data = BitConverter.GetBytes(floatVal); else { error = "Geçersiz Float32"; return false; }
                        break;
                    case "Float64":
                        if (double.TryParse(text, NumberStyles.Float, CultureInfo.InvariantCulture, out double doubleVal)) data = BitConverter.GetBytes(doubleVal); else { error = "Geçersiz Float64"; return false; }
                        break;
                    case "Bytes (Hex)":
                        {
                            string hex = text.Replace(" ", string.Empty).Replace("-", string.Empty);
                            if (hex.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) hex = hex.Substring(2);
                            if (hex.Length % 2 != 0) hex = "0" + hex;
                            try
                            {
                                data = new byte[hex.Length / 2];
                                for (int idx = 0; idx < data.Length; idx++) data[idx] = byte.Parse(hex.Substring(idx * 2, 2), NumberStyles.HexNumber);
                            }
                            catch { error = "Geçersiz hex bayt dizisi"; return false; }
                        }
                        break;
                    default:
                        error = "Bilinmeyen tip"; return false;
                }
                return true;
            }
            catch (Exception ex) { error = ex.Message; return false; }
        }

        // For 'Int' search build multiple subtypes
        private List<(string subtype, byte[] bytes)> BuildTargets(string type, string valueText, out string error)
        {
            error = null;
            var list = new List<(string, byte[])>();
            if (type == "Int")
            {
                string[] intSubtypes = new[] { "Int8", "UInt8", "Int16", "UInt16", "Int32", "UInt32", "Int64", "UInt64" };
                foreach (var s in intSubtypes)
                {
                    if (GetBytesForType(s, valueText, out byte[] bytes, out string err)) list.Add((s, bytes));
                }
                if (!list.Any()) error = "Geçersiz Int değeri";
                return list;
            }
            else
            {
                if (GetBytesForType(type, valueText, out byte[] bytes, out string err)) list.Add((type, bytes)); else error = err;
                return list;
            }
        }

        private async void btnScan_Click(object sender, EventArgs e)
        {
            if (cbProcesses.SelectedItem == null) { MessageBox.Show("Lütfen bir process seçin."); return; }
            if (string.IsNullOrWhiteSpace(txtValue.Text)) { MessageBox.Show("Lütfen aranacak değeri girin."); return; }

            var item = cbProcesses.SelectedItem as ProcessItem;
            var process = item.Process;
            string searchType = cbType.SelectedItem?.ToString() ?? "Int";
            string searchValue = txtValue.Text;

            lstResults.Items.Clear();
            lastFoundAddresses.Clear();
            lastSearchType = searchType;
            
            // Progress bar'ı sıfırla
            progressBarScan.Value = 0;
            progressBarScan.Maximum = 100;
            
            AddStatus("Tarama başlıyor...");

            var targets = BuildTargets(searchType, searchValue, out string buildErr);
            if (buildErr != null) { AddStatus(buildErr); return; }

            var progress = new Progress<int>(percent => 
            {
                if (progressBarScan != null && !progressBarScan.IsDisposed)
                    progressBarScan.Value = Math.Min(percent, 100);
            });

            await Task.Run(() => ScanProcessAndStore(process, targets, progress));

            progressBarScan.Value = 100;
            AddStatus("Tamamlandı");
        }

        // region-based scan with overlap
        private void ScanProcessAndStore(Process process, List<(string subtype, byte[] bytes)> targets, IProgress<int> progress = null)
        {
            try
            {
                IntPtr hProcess = OpenProcess(PROCESS_WM_READ | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION, false, process.Id);
                if (hProcess == IntPtr.Zero) { AddStatus($"{process.ProcessName}: açılmadı"); AppendLog("OpenProcess returned zero."); return; }

                lastFoundAddresses.Clear();

                IntPtr address = IntPtr.Zero;
                int structSize = Marshal.SizeOf(typeof(MEMORY_BASIC_INFORMATION));

                int maxTlen = 0; foreach (var t in targets) if (t.bytes != null && t.bytes.Length > maxTlen) maxTlen = t.bytes.Length;
                if (maxTlen <= 0) { AddStatus("Aranacak hedef boş"); CloseHandle(hProcess); return; }
                int overlap = Math.Max(0, maxTlen - 1);

                int totalMatches = 0;

                // İlk geçiş: toplam taranacak bellek boyutunu hesapla
                long totalMemoryToScan = 0;
                var regionsToScan = new List<(IntPtr baseAddr, long size)>();
                IntPtr tempAddr = IntPtr.Zero;
                
                while (true)
                {
                    MEMORY_BASIC_INFORMATION mbi;
                    var res = VirtualQueryEx(hProcess, tempAddr, out mbi, (UIntPtr)structSize);
                    if (res == UIntPtr.Zero) break;

                    long regionSize = mbi.RegionSize.ToInt64();
                    bool isCommitted = (mbi.State & MEM_COMMIT) != 0;
                    bool noAccess = (mbi.Protect & PAGE_NOACCESS) != 0;
                    bool guard = (mbi.Protect & PAGE_GUARD) != 0;
                    bool isReadable = isCommitted && !noAccess && !guard;

                    if (isReadable)
                    {
                        uint prot = mbi.Protect;
                        bool writable = ((prot & PAGE_READWRITE) != 0) || ((prot & PAGE_WRITECOPY) != 0) || ((prot & PAGE_EXECUTE_READWRITE) != 0) || ((prot & PAGE_EXECUTE_WRITECOPY) != 0);
                        if (writable && regionSize > 0)
                        {
                            regionsToScan.Add((mbi.BaseAddress, regionSize));
                            totalMemoryToScan += regionSize;
                        }
                    }

                    long next = mbi.BaseAddress.ToInt64() + mbi.RegionSize.ToInt64();
                    if (next >= long.MaxValue) break;
                    tempAddr = new IntPtr(next);
                }

                // İkinci geçiş: tarama yap ve progress güncelle
                long scannedMemory = 0;
                int lastPercent = 0;

                foreach (var region in regionsToScan)
                {
                    long regionSize = region.size;
                    long offset = 0;
                    const int chunk = 0x10000 =
